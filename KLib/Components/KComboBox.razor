@using System.ComponentModel
@using System.Diagnostics
@using Microsoft.JSInterop

@inject IJSRuntime JSRuntime

@typeparam TValue
@typeparam TItem

<select id="@Id" disabled="@Disabled"
        class="@("form-select placeholder-active" + (string.IsNullOrEmpty(CssClass) ? string.Empty : " ") + CssClass)"
        aria-label="@AreaLabel"
        @onchange="OnValueChanged" @attributes="InputAttributes">
    @if (DataSource == null)
    {
        <option value="" selected disabled>Loading...</option>
    }
    else
    {
        if (Value == null)
        {
            <option value="" selected>@Placeholder</option>
        }
        else if (!string.IsNullOrWhiteSpace(Placeholder))
        {
            <option value="">@Placeholder</option>
        }

        @foreach (var item in DataSource)
        {
            if (Value != null && GetValue(item)!.Equals(Value))
            {
                <option value="@GetValue(item)" selected>@GetDescription(item)</option>
            }
            else
            {
                <option value="@GetValue(item)">@GetDescription(item)</option>
            }
        }
    }
</select>
<script>
    function updateSelectClass(selectElementId, isPlaceholderActive) {
        let selectElement = document.getElementById(selectElementId);
        if (isPlaceholderActive) {
            selectElement.classList.add("placeholder-active");
        } else {
            selectElement.classList.remove("placeholder-active");
        }
    }
</script>

@code {
    [Parameter] public string Id { get; set; } = Guid.NewGuid().ToString();

    [Parameter(CaptureUnmatchedValues = true)]
    public Dictionary<string, object>? InputAttributes { get; set; }

    [Parameter] public string AreaLabel { get; set; } = null!;

    [Parameter] public string Placeholder { get; set; } = null!;

    [Parameter] public TValue? Value { get; set; }

    [Parameter] public EventCallback<TValue> ValueChanged { get; set; }

    [Parameter] [EditorRequired] public IEnumerable<TItem>? DataSource { get; set; }

    [Parameter] public string? ValueField { get; set; }

    [Parameter] public string? DisplayField { get; set; }

    [Parameter] public Func<TItem, string>? DisplayFunc { get; set; }

    [Parameter] public bool Disabled { get; set; }

    [Parameter] public string? CssClass { get; set; }

    private ElementReference _selectElement;

    private TValue? _lastValue;

    private bool _rendered = false;

    protected override void OnAfterRender(bool firstRender)
    {
        base.OnAfterRender(firstRender);
        _rendered = true;
    }

    protected override async Task OnParametersSetAsync()
    {
        if (_rendered && ((_lastValue != null && Value == null) || (_lastValue == null && Value != null) || (_lastValue != null && !_lastValue.Equals(Value))))
        {
            _lastValue = Value;
            await UpdatePlaceholderStyle();
        }

        await base.OnParametersSetAsync();
    }

    private async Task UpdatePlaceholderStyle()
    {
        var isPlaceholderActive = string.IsNullOrWhiteSpace(Value?.ToString()) || EqualityComparer<TValue>.Default.Equals(Value, default(TValue));
        await JSRuntime.InvokeVoidAsync("updateSelectClass", this.Id, isPlaceholderActive);
    }

    private TValue GetValue(TItem item)
    {
        if (ValueField == null)
            return (TValue)((object?)item!);
        return (TValue)item!.GetType().GetProperty(ValueField)!.GetValue(item)!;
    }

    private string? GetDescription(TItem item)
    {
        if (item == null)
            return default;

        Debug.Assert(!(DisplayField != null && DisplayFunc != null), "Cannot set both DisplayField and DisplayFunc");

        if (DisplayField == null && DisplayFunc == null)
            return item.ToString();

        if (DisplayFunc != null)
            return DisplayFunc(item);

        var splitted = DisplayField.Split(".");
        if (splitted.Length > 1)
        {
            object? obj = item;
            foreach (var prop in splitted)
            {
                if (obj == null)
                    return default;
                obj = obj.GetType().GetProperty(prop)!.GetValue(obj);
            }

            if (obj == null)
                return default;

            return (string?)obj;
        }
        else
        {
            return (string?)item.GetType().GetProperty(DisplayField)!.GetValue(item);
        }
    }


    private async Task OnValueChanged(ChangeEventArgs obj)
    {
        var newValue = obj.Value;

        if (newValue == null || string.IsNullOrEmpty(newValue.ToString()))
        {
            Value = default;
        }
        else
        {
            var typeConverter = TypeDescriptor.GetConverter(typeof(TValue));
            Value = (TValue)typeConverter.ConvertFromString(newValue.ToString()!)!;
        }

        await ValueChanged.InvokeAsync(Value);
        await UpdatePlaceholderStyle();
    }

}