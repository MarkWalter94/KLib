@using System.Globalization
@using System.Linq.Expressions
@using KLib.Options
@using Microsoft.AspNetCore.Components.Forms
@using Microsoft.Extensions.Options

@typeparam TValue

@inject IOptions<KLibOptions> KLibOptions
<div>
    @if (!string.IsNullOrWhiteSpace(Placeholder))
    {
        <label for="@Id" class="form-label">@Placeholder</label>
    }
    @if (Type != InputDateType.Time)
    {
        <InputDate id="@Id" class="@("form-control" + (string.IsNullOrEmpty(CssClass) ? string.Empty : " ") + CssClass)"
                   TValue="TValue" Type="Type" @attributes="InputAttributes"
                   Value="_localValue" ValueChanged="OnValueChanged" ValueExpression="ValueExpression"/>
    }
    else
    {
        <input type="time"
               class="@("form-control" + (string.IsNullOrEmpty(CssClass) ? string.Empty : " ") + CssClass)"
               value="@CurrentValueAsString"
               @oninput="OnTimeInput"
               @attributes="InputAttributes"/>
    }
</div>

@code {
    [Parameter] public string Id { get; set; } = Guid.NewGuid().ToString();

    [Parameter(CaptureUnmatchedValues = true)]
    public Dictionary<string, object>? InputAttributes { get; set; }

    private TValue _oldValue;
    [Parameter] public TValue Value { get; set; }

    private TValue _localValue { get; set; }

    [Parameter] public string? Placeholder { get; set; }

    [Parameter] public EventCallback<TValue> ValueChanged { get; set; }

    [Parameter] public Expression<Func<TValue>>? ValueExpression { get; set; }

    [Parameter] public InputDateType Type { get; set; }

    [Parameter] public bool ConvertToUTC { get; set; }

    [Parameter] public string? CssClass { get; set; }

    private string? CurrentValueAsString { get; set; }

    protected override void OnInitialized()
    {
        this.ConvertToUTC = KLibOptions.Value.ConvertDateTimesToUtc;
        if (this.Type == InputDateType.Time)
            this.ConvertToUTC = false;
        base.OnInitialized();
    }

    protected override void OnParametersSet()
    {
        if (ConvertToUTC && Type != InputDateType.Time)
        {
            if (!EqualityComparer<TValue>.Default.Equals(Value, _oldValue))
            {
                if (Value is DateTime dateTime)
                {
                    if (Type == InputDateType.Date || Type == InputDateType.Month)
                        _localValue = (TValue)(object)new DateTime(dateTime.Year, dateTime.Month, dateTime.Day, 0, 0, 0, DateTimeKind.Local);
                    else
                        _localValue = (TValue)(object)dateTime.ToLocalTime();
                }
                else if (Value is DateOnly dateOnly)
                {
                    if (typeof(TValue) == typeof(DateTime) || typeof(TValue) == typeof(DateTime?))
                        _localValue = (TValue)(object)new DateTime(dateOnly.Year, dateOnly.Month, dateOnly.Day, 0, 0, 0, DateTimeKind.Local);
                    else if (typeof(TValue) == typeof(DateOnly) || typeof(TValue) == typeof(DateOnly?))
                        _localValue = (TValue)(object)dateOnly;
                }
                else
                {
                    throw new InvalidOperationException("The value must be a DateTime to be converted to UTC");
                }

                _oldValue = Value;
            }
        }

        if (Type == InputDateType.Time && Value is TimeOnly time)
        { 
            CurrentValueAsString = time.ToString("HH:mm", CultureInfo.InvariantCulture);
        }

        base.OnParametersSet();
    }

    private void OnValueChanged(TValue newValue)
    {
        _localValue = newValue;
        //Convert always the value to UTC
        if (!ConvertToUTC)
        {
            Value = newValue;
        }
        else
        {
            if (newValue is DateTime dateTime)
            {
                if (Type == InputDateType.Date || Type == InputDateType.Month)
                    Value = (TValue)(object)new DateTime(dateTime.Year, dateTime.Month, dateTime.Day, 0, 0, 0, DateTimeKind.Utc);
                else
                    Value = (TValue)(object)dateTime.ToUniversalTime();
            }
            else if (newValue is DateOnly dateOnly)
            {
                if (typeof(TValue) == typeof(DateTime) || typeof(TValue) == typeof(DateTime?))
                {
                    Value = (TValue)(object)new DateTime(dateOnly.Year, dateOnly.Month, dateOnly.Day, 0, 0, 0, DateTimeKind.Utc);
                }
                else if (typeof(TValue) == typeof(DateOnly) || typeof(TValue) == typeof(DateOnly?))
                {
                    Value = (TValue)(object)newValue;
                }
            }
            else
            {
                throw new InvalidOperationException("The value must be a DateTime to be converted to UTC");
            }
        }

        ValueChanged.InvokeAsync(Value);
    }

    private async Task OnTimeInput(ChangeEventArgs e)
    {
        var value = e.Value?.ToString();
        CurrentValueAsString = value;

        if (TimeOnly.TryParseExact(value, "HH:mm:ss", CultureInfo.InvariantCulture, DateTimeStyles.None, out var time))
        {
            _localValue = (TValue)(object)time;
            Value = _localValue;
            await ValueChanged.InvokeAsync(Value);
        }
        else if (TimeOnly.TryParseExact(value, "HH:mm", CultureInfo.InvariantCulture, DateTimeStyles.None, out time))
        {
            _localValue = (TValue)(object)time;
            Value = _localValue;
            await ValueChanged.InvokeAsync(Value);
        }
        else
        {
            //Invalid time format
        }
    }

}